<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title> - A thoughtful introduction to the pest parser</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="An introduction to the pest parser by implementing a Rust grammar subset">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

        <!-- Custom JS script -->
        

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="./intro.html">Introduction</a></li><li><a href="./setup.html"><strong>1.</strong> Setup</a></li><li><a href="./peg.html"><strong>2.</strong> Parsing expression grammar</a></li><li><a href="./literals.html"><strong>3.</strong> Literals</a></li><li><a href="./syntax.html"><strong>4.</strong> Syntax</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title">A thoughtful introduction to the pest parser</h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#introduction" id="introduction"><h1>Introduction</h1></a>
<p><em>Speed or simplicity? Why not <strong>both</strong>?</em></p>
<p>The motivation behind <em>pest</em> was to come up with a parser that would maximize
usability, both when designing the grammar, and when maintaining it after
prolonged use and development. And, as Rust tradition mandates, this parser had
to make sure that its use of high-level abstractions would not hinder
performance. As such, <em>pest</em> is perfectly suited for complete beginners who want
to learn and experiment with grammars and parsing, but who do not want to be
constrained in terms of speed.</p>
<p><em>pest</em> is implemented in Rust and requires some knowledge of the language in
order to be used. The reason for picking it over other languages is that it
offers C-like low level access and encourages the use of multi-threaded
programming, both of great use when writing a compiler or VM to accompany your
parser. At the same time, Rust's procedural macros and functional APIs provide a
means to express the problem of parsing in a simple and natural way. It even
comes with an <a href="https://doc.rust-lang.org/book/">official book</a> to get you
started.</p>
<p>This introduction will explore the implementation of a subset of Rust's own
grammar, from the simplest terminals to the construction of an AST. After
reading it, you should be comfortable writing parsers with <em>pest</em>.</p>
<a class="header" href="print.html#setup" id="setup"><h1>Setup</h1></a>
<p>Before getting into the more theoretical parts of grammars and APIs, let's first
make sure we're all set up.</p>
<a class="header" href="print.html#rust and cargo" id="rust and cargo"><h2>Rust and Cargo</h2></a>
<p>The easiest way to install Rust and Cargo together is to follow the instructions
on <a href="https://rustup.rs">rustup.rs</a>. Once that is out of the way, make sure you
add <em>pest</em> to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">pest = &quot;^1.0.0-beta&quot;
pest_derive = &quot;^1.0.0-beta&quot;
</code></pre>
<p><em>pest_derive</em> is the part of the parser that analyzes, verifies, optimizes, and
generates the code that then makes use of the APIs found in the <em>pest</em> crate.
This is separate because the actual procedural macro that derives the parser for
you is linked at compile time.</p>
<a class="header" href="print.html#the pest grammar file" id="the pest grammar file"><h2>The <code>.pest</code> grammar file</h2></a>
<p>The actual grammar gets saved in separate <code>.pest</code> files, relative to Cargo's
<code>src</code> directory. They are then used in order to derive an implementation of the
<a href="https://docs.rs/pest/1.0.0-beta/pest/trait.Parser.html">Parser</a> trait.</p>
<p>Due to the fact that procedural macro do not offer an API to tell the compiler
which files are relevant to compilation, it is necessary to provide a small hint
in the form of a debug-only <code>const</code> in order to make sure that your grammar gets
recompiled after every change.</p>
<p>So, you should add the following code to the Rust file where you want the parser
to be.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(debug_assertions)]
const _GRAMMAR: &amp;'static str = include_str!(&quot;path/to/rust.pest&quot;); // relative to this file

#[derive(Parser)]
#[grammar = &quot;path/to/rust.pest&quot;] // relative to src
struct RustParser;
#}</code></pre></pre>
<p>Also, don't forget to add the crate dependency in your crate's main file.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate pest;
#[macro_use]
extern crate pest_derive;
#}</code></pre></pre>
<a class="header" href="print.html#parsing expression grammar" id="parsing expression grammar"><h1>Parsing expression grammar</h1></a>
<p>Parsing expression grammar, or PEG, is the formal grammar that <em>pest</em> uses to
describe the kind of inputs it accepts. This type of grammar is similar in
concept to regular expressions with named groups with the exception that regex
is <em>generative</em>, i.e. used to generate strings, while PEG is <em>analytic</em>, i.e.
used to test whether strings match the grammar.</p>
<a class="header" href="print.html#generative vs analytics approach" id="generative vs analytics approach"><h2>Generative vs. analytics approach</h2></a>
<p>Let's take a look at a simple regex example in order to illustrate these
concepts a bit better:</p>
<pre><code class="language-javascript">/^(a*)(a)$/
</code></pre>
<p>This regex generates a string that starts from the beginning (<code>^</code>), matches zero
or more <code>'a'</code> (<code>a*</code>), matches one <code>'a'</code> (<code>a</code>), then it makes sure it reached the
end of its input. Since this a generative definition, we can generate the string
<code>&quot;aa&quot;</code> by generating one <code>'a'</code> from the first group and the second <code>'a'</code> from
the second group.</p>
<p>If we define the same rule in pest, it will look something like this:</p>
<pre><code>soi ~ &quot;a&quot;* ~ &quot;a&quot; ~ eoi
</code></pre>
<p><code>soi</code> and <code>eoi</code> stand for start-of-input and end-of-input respectively and work
much like their regex counterparts. <code>~</code> is used in order to crate sequences,
while the rest of the syntax should be straightforward coming from the previous
example.</p>
<p>Part of the analytical approach of PEGs is the fact that they run eagerly. If we
take the example generated by the regex, the PEG variant will eagerly match both
<code>a</code>s in the <code>&quot;a&quot;*</code> expression, leaving the second <code>&quot;a&quot;</code> unsatisfied. Every
expression in PEG tries to match as much as it possibly can. And, once it
matched, it will not backtrack in order to satisfy the next expression. At
first, this may seem like a bit of a hindrance, but it offer something else in
exchange.</p>
<a class="header" href="print.html#non-ambiguity" id="non-ambiguity"><h2>Non-ambiguity</h2></a>
<p>If a string is accepted by a PEG grammar, it is guaranteed to be matched in one
single manner. Let's take the following regex example in order to illustrate
this:</p>
<pre><code class="language-javascript">/(a*)(a*)/
</code></pre>
<p>The string <code>&quot;aaaa&quot;</code> has, theoretically, 5 different ways of being accepted in
terms of how the groups are split, namely <code>(&quot;aaaa&quot;)()</code>, <code>(&quot;aaa&quot;)(&quot;a&quot;)</code>,
<code>(&quot;aa&quot;)(&quot;aa&quot;)</code>, <code>(&quot;a&quot;)(&quot;aaa&quot;)</code>, and <code>()(&quot;aaaa&quot;)</code>. The only way the equivalent
PEG grammar can match this is by eagerly matching the whole string in the first
expression <code>(&quot;aaaa&quot;)()</code>.</p>
<a class="header" href="print.html#choice order" id="choice order"><h2>Choice order</h2></a>
<p>In order to keep the promise of non-ambiguity, choice expressions have to be run
in a predefined order, from right to left. This has an relevant implication when
rules have overlapping beginnings. Take the following example:</p>
<pre><code>(&quot;a&quot; | &quot;ab&quot;) ~ eoi
</code></pre>
<p>This may look perfectly correct, but is in fact incapable of accepting the
string <code>&quot;ab&quot;</code>, since the first choice will match <code>&quot;a&quot;</code>, leaving <code>&quot;b&quot;</code> at the
hand of the <code>eoi</code> rule which will then fail. And, since there is no way to match
<code>&quot;ab&quot;</code>, it can be simplified to simply <code>&quot;a&quot; ~ eoi</code>. If, however, we do want to
match both, we have to make sure that the longer expression comes first:</p>
<pre><code>(&quot;ab&quot; | &quot;a&quot;) ~ eoi
</code></pre>
<p>This way, <code>&quot;ab&quot;</code> will get matched by the first expression, while <code>&quot;a&quot;</code> will fail
it, making way for the second one to match.</p>
<a class="header" href="print.html#left-recursion" id="left-recursion"><h2>Left-recursion</h2></a>
<p>Because of their eager nature, PEGs will always start exploring possible paths
from the left. This means that, if a rules gets to run itself before making any
kind of progress, it will result in a stack-overflow. The following examples all
fail to compile:</p>
<pre><code>// Rule calls itself right away.
rule = { rule }

// Rule makes no progress before calling itself. (since &quot;&quot; always matches)
rule = { &quot;&quot; ~ rule }

// Rules indirectly left-recurse.
rule_a = { rule_b }
rule_b = { rule_a }

// Rule still causes a stack-overflow for any other input than &quot;a&quot;.
rule = { &quot;a&quot; | rule }
</code></pre>
<p>All left-recursion use cases can be rewritten in PEG using repetition or layers
of indirection, as will be seen in later chapters.</p>
<a class="header" href="print.html#literals" id="literals"><h1>Literals</h1></a>
<p>A good place to start when writing out the grammar of a language are the
literals. For our small Rust subset, the literals that we are going to define
are booleans, integers, floating point numbers, strings, characters, types, and
identifiers.</p>
<a class="header" href="print.html#booleans" id="booleans"><h2>Booleans</h2></a>
<p>Defining booleans is probably the easiest step. We need a rule with two
variants, <code>true</code> and <code>false</code>:</p>
<pre><code>bool = { &quot;true&quot; | &quot;false&quot; }
</code></pre>
<p>This, however, will only generate a token for the <code>bool</code> rule without telling us
which variant it is, forcing us to dig through the input in order to see whether
it is <code>true</code> or <code>false</code>. In order to parse this only once and get the necessary
information right away, we can make <code>true</code> and <code>false</code> separate rules:</p>
<pre><code>true  = { &quot;true&quot; }
false = { &quot;false&quot; }
bool  = { true | false }
</code></pre>
<p>Unfortunately, running <code>cargo check</code> will print the following error:</p>
<pre><code>grammar error

 --&gt; rust.pest:1:1
  |
1 | true  = { &quot;true&quot; }
  | ^--^
  |
  = true is a rust keyword

grammar error

 --&gt; rust.pest:2:1
  |
2 | false = { &quot;false&quot; }
  | ^---^
  |
  = false is a rust keyword
</code></pre>
<p>This is because every one of the rules you define will populate an <code>enum</code> named
<code>Rule</code>. Thus, if any rules conflict with Rust's naming scheme, it will error
out with an ambiguous message which is why <em>pest</em> tries its best to catch any
possible error before it reaches the compiler.</p>
<p>A simple (but less elegant) solution here would be to suffix these rules with
<code>_lit</code>:</p>
<pre><code>true_lit  = { &quot;true&quot; }
false_lit = { &quot;false&quot; }
bool      = { true_lit | false_lit }
</code></pre>
<p>This seems to work fine, but before we head on to integers, let's first write a
couple of tests. <em>pest</em> comes with a handy macro for asserting parse results
named <a href="https://docs.rs/pest/1.0.0-beta/pest/macro.parses_to.html">parses_to!</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn true_lit() {
    parses_to! {
        parser: RustParser,     // our parser struct
        input: &quot;true&quot;,          // the input we're testing
        rule: Rule::bool,       // the rule that should be run
        tokens: [
            bool(0, 4, [        // name_of_rule(start_pos, end_pos, [children])
                true_lit(0, 4)  // name_of_rule(start_pos, end_pos): no children
            ])
        ]
    };
}

#[test]
fn false_lit() {
    parses_to! {
        parser: RustParser,
        input: &quot;false&quot;,
        rule: Rule::bool,
        tokens: [
            bool(0, 5, [
                false_lit(0, 5)
            ])
        ]
    };
}
#}</code></pre></pre>
<a class="header" href="print.html#integers" id="integers"><h2>Integers</h2></a>
<p>Although not as trivial as the booleans, integers should be quite
straightforward. In our implementation, we will only implement decimal integers
which start with a digit, then continue with any mixture of digits and
underscores:</p>
<pre><code>int = { '0'..'9' ~ ('0'..'9' | &quot;_&quot;)* }
</code></pre>
<p>In the example above, the range defining a digit (<code>'0'..'9'</code>) is repeated and
can be turned into a rule. Since we do not want it to generate tokens or be
reported in errors, we will make it silent (<code>_</code>).</p>
<pre><code>digit = _{ '0'..'9' }
int   =  { digit ~ (digit | &quot;_&quot;)* }
</code></pre>
<p>Testing a few cases like <code>&quot;0&quot;</code>, <code>&quot;01&quot;</code>, <code>&quot;0___&quot;</code>, <code>&quot;1_000_000&quot;</code> should suffice.</p>
<a class="header" href="print.html#floating point numbers" id="floating point numbers"><h2>Floating point numbers</h2></a>
<p>Here is where it starts to become a little bit tricky. Floating points come in
two different shapes:</p>
<ul>
<li>integer literal followed by a <code>'.'</code>, followed by another optional integer
literal, followed by an optional exponent</li>
<li>integer literal, followed by a an exponent</li>
</ul>
<p>By abstracting the definition of the exponent, the grammar will look like this:</p>
<pre><code>float = {
    int ~ &quot;.&quot; ~ int? ~ exp? |
    int ~ exp
}
</code></pre>
<p>The exponent part is a case insensitive <code>'e'</code>, followed by an optional sign
(<code>'+'</code>/<code>'-'</code>), followed by an integer. To match a string insensitively, you can
use the <code>^</code> prefix operator. Again, we would like to keep track of the signs in
order not to have to parse again, so we make the signs separate rules:</p>
<pre><code>plus  = { &quot;+&quot; }
minus = { &quot;-&quot; }
exp   = { ^&quot;e&quot; ~ (plus | minus)? ~ int }
</code></pre>
<p>Testing floating point numbers should take into consideration their nested
integer and exponent tokens:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn zero_point() {
    parses_to! {
        parser: RustParser,
        input: &quot;0.&quot;,
        rule: Rule::float,
        tokens: [
            float(0, 2, [
                int(0, 1)
            ])
        ]
    };
}

#[test]
fn one_exponent() {
    parses_to! {
        parser: RustParser,
        input: &quot;1e10&quot;,
        rule: Rule::float,
        tokens: [
            float(0, 4, [
                int(0, 1),
                exp(1, 4, [
                    int(2, 4)
                ])
            ])
        ]
    };
}
#}</code></pre></pre>
<p>More interesting test cases could be <code>&quot;0.e0&quot;</code>, <code>&quot;0.0e+0&quot;</code>, <code>&quot;0.0&quot;</code>,
<code>&quot;0__.0__e-0__&quot;</code>.</p>
<a class="header" href="print.html#strings" id="strings"><h2>Strings</h2></a>
<p>Strings can get a little bit tricky since you have to make sure that you include
string escapes in your grammar. This is needed since you have no other way of
knowing exactly where the string ending quote will be and also because it makes
escaping easier later on.</p>
<p>Let's start by focusing on the high level definition. A string is a repetition
of raw string parts (containing no escapes) and actual escapes, all enclosed
within a pair of quotes:</p>
<pre><code>string = { &quot;\&quot;&quot; ~ (raw_string | escape)* ~ &quot;\&quot;&quot; }
</code></pre>
<p>Raw strings can basically be any character apart from <code>'\'</code>, since that means
we're about to start an escape clause, and <code>'&quot;'</code>, since that means we're about
to end the string. In order to match anything but these two characters, we look
ahead and fail the rule if we match these two characters. For this, we're going
to use a negative lookahead (<code>!</code>). After we made sure that we're matching the
correct character, we use the predefined rule <code>any</code> to actually force the parser
to skip this character, since the lookahead is non-destructive:</p>
<pre><code>raw_string = { (!(&quot;\\&quot; | &quot;\&quot;&quot;) ~ any)+ }
</code></pre>
<p>Rust string literals can be:</p>
<ul>
<li>predefined: <code>'\n'</code>, <code>'\r'</code>, <code>'\t'</code>, <code>'\\'</code>, <code>'\0'</code>,</li>
<li>bytes: <code>'\x$$'</code>, where <code>$$</code> are two hexadecimal digits</li>
<li>unicode: <code>\u{$}</code> - <code>\u{$$$$$$}</code>, where <code>$</code>s are from 1 up to 6 hexadecimal
digits</li>
</ul>
<p>A good place to start is to define the hex digit:</p>
<pre><code>hex = _{ '0'..'9' | 'a'..'f' | 'A'..'F' }
</code></pre>
<p>To define a rule that can have from 1 up to 6 hex digits is to check whether
you have 6 already, and, if not, to match as many as possible. This way, if you
have more than 6, the rule will match the 6 and fail later down the path. It you
have less than 6, the second part of the choice will obviously match less than 6
as well.</p>
<pre><code>unicode_hex = { hex ~ hex ~ hex ~ hex ~ hex ~ hex | hex+ }
</code></pre>
<p>We now have everything we need to define escapes:</p>
<pre><code>predefined = { &quot;n&quot; | &quot;r&quot; | &quot;t&quot; | &quot;\\&quot; | &quot;0&quot; | &quot;\&quot;&quot; | &quot;'&quot; }
byte       = { &quot;x&quot; ~ hex ~ hex }
unicode    = { &quot;u&quot; ~ &quot;{&quot; ~ unicode_hex ~ &quot;}&quot; }
escape     = { &quot;\\&quot; ~ (predefined | byte | unicode) }
</code></pre>
<p>For the sake of compactness, we can write a single test that encompasses
everything interesting:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn string_with_all_escape_types() {
    parses_to! {
        parser: RustParser,
        input: r#&quot;&quot;a\nb\x0Fc\u{a}d\u{AbAbAb}e&quot;&quot;#,
        rule: Rule::string,
        tokens: [
            string(0, 28, [
                raw_string(1, 2),
                escape(2, 4, [
                    predefined(3, 4)
                ]),
                raw_string(4, 5),
                escape(5, 9, [
                    byte(6, 9)
                ]),
                raw_string(9, 10),
                escape(10, 15, [
                    unicode(11, 15, [
                        unicode_hex(13, 14)
                    ])
                ]),
                raw_string(15, 16),
                escape(16, 26, [
                    unicode(17, 26, [
                        unicode_hex(19, 25)
                    ])
                ]),
                raw_string(26, 27)
            ])
        ]
    };
}
#}</code></pre></pre>
<a class="header" href="print.html#characters" id="characters"><h2>Characters</h2></a>
<p>Characters are very similar to strings, with the obvious exception that may only
store one character:</p>
<pre><code>chr = { &quot;'&quot; ~ (escape | any) ~ &quot;'&quot; }
</code></pre>
<p>Tests should cover at least the usual and the escape cases, e.g. <code>&quot;'a'&quot;</code>,
<code>&quot;'\''&quot;</code>.</p>
<a class="header" href="print.html#types" id="types"><h2>Types</h2></a>
<p>Types should only be the few primitives defined here:</p>
<pre><code>i32_ty  = { &quot;i32&quot; }
f32_ty  = { &quot;f32&quot; }
char_ty = { &quot;char&quot; }
str_ty  = { &quot;str&quot; }

ty = { i32_ty | f32_ty | char_ty | str_ty }
</code></pre>
<p>Writing one test for each of the four cases should suffice.</p>
<a class="header" href="print.html#identifiers" id="identifiers"><h2>Identifiers</h2></a>
<p>Full-blown Rust identifiers can be a bit complex, so we will only focus on ASCII
variants:</p>
<ul>
<li>an identifier is made up of alphanumeric characters and underscores</li>
<li>the first character cannot be a digit</li>
<li>underscores need to be followed by at least another character</li>
</ul>
<p>This can be implemented by having a choice clause between two cases:</p>
<pre><code>ident_char = _{ 'a'..'z' | 'A'..'Z' | '0'..'9' | &quot;_&quot; }
ident      =  {
    ('a'..'z' | 'A'..'Z') ~ ident_char* |
    &quot;_&quot; ~ ident_char+
}
</code></pre>
<p>Interesting test cases could be <code>&quot;aBc0&quot;</code>, <code>&quot;_0AbC&quot;</code>.</p>
<a class="header" href="print.html#syntax" id="syntax"><h1>Syntax</h1></a>
<p>Now that we have literals defined, the next step is to compose them into the
syntax of the language. This syntax will only focus on expressions, statements,
and functions as a subset of Rust. These in turn will not be complete
definitions.</p>
<a class="header" href="print.html#expressions" id="expressions"><h2>Expressions</h2></a>
<p>We will define expressions as a combination of unary and infix operations, and
method calls. The operators that we will use for this subset are:</p>
<pre><code>op_unary_minus =  { &quot;-&quot; }
op_unary_not   =  { &quot;!&quot; }
op_unary       = _{
    op_unary_minus |
    op_unary_not
}

op_plus          =  { &quot;+&quot; }
op_minus         =  { &quot;-&quot; }
op_times         =  { &quot;*&quot; }
op_divide        =  { &quot;/&quot; }
op_and           =  { &quot;&amp;&amp;&quot; }
op_or            =  { &quot;||&quot; }
op_greater       =  { &quot;&gt;&quot; }
op_greater_equal =  { &quot;&gt;=&quot; }
op_lower         =  { &quot;&lt;&quot; }
op_lower_equal   =  { &quot;&lt;=&quot; }
op_equal         =  { &quot;==&quot; }
op_infix         = _{
    op_plus |
    op_minus |
    op_times |
    op_divide |
    op_and |
    op_or |
    op_greater |
    op_greater_equal |
    op_lower |
    op_lower_equal |
    op_equal
}

paren_open  = { &quot;(&quot; }
paren_close = { &quot;)&quot; }
</code></pre>
<p>We also defined parentheses rules since they will come in handy in a bit.
Because PEGs do not support left-recursion, we will have to make sure to have
a layer of indirection when defining infix expressions, while unaries and method
calls will be defined with the use of repetitions.</p>
<p>The easiest way to start would be to define expressions with the highest
priorities. These expressions will be the only ones that unaries can be formed
with and methods can be called on. They are the literals defined in the previous
chapter plus expressions nested in parentheses:</p>
<pre><code>value = {
    float | // float comes before int since they overlap
    int |
    chr |
    string |
    ident |
    paren_open ~ expr ~ paren_close
}
</code></pre>
<p>With that out of the way, a next step would be to define what a call should look
like:</p>
<pre><code>dot   =  { &quot;.&quot; }
comma =  { &quot;,&quot; }
args  = _{ expr ~ (comma ~ expr)* }
call  =  { ident ~ paren_open ~ args? ~ paren_close }
</code></pre>
<p>Now we can include unaries and method calls in one single term rule that will
be used in infix expressions:</p>
<pre><code>term = { op_unary* ~ value ~ (dot ~ call)* }
expr = { term ~ (op_infix ~ term)* }
</code></pre>
<p>Extensive testing would be handy here, especially more complex cases that
combine expression types, but also separate tests for individual behavior.</p>
<a class="header" href="print.html#statements" id="statements"><h2>Statements</h2></a>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        
    <script type="text/javascript">
        var socket = new WebSocket("ws://localhost:3001");
        socket.onmessage = function (event) {
            if (event.data === "reload") {
                socket.close();
                location.reload(true); // force reload from server (not from cache)
            }
        };

        window.onbeforeunload = function() {
            socket.close();
        }
    </script>


        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
